points(x = iris$Sepal.Length, y = predict(m, type = "response"), col = iris$Species, type = "line")
m2 = glm(Petal.Length~Sepal.Length+Species, data = iris)
summary(m2)
plot(Petal.Length~Sepal.Length, data = iris, col = Species)
vec = runif(nrow(iris), 0, 1)
m3 = glm(Petal.Length~Sepal.Length*Species+vec, data = iris)
summary(m3)
AIC(m1)
AIC(m)
m3 = glm(Petal.Length~Sepal.Length*Species+vec, data = iris)
vec = runif(nrow(iris), 0, 1)
m3 = glm(Petal.Length~Sepal.Length*Species+vec, data = iris)
summary(m3)
plot(iris$Petal.Length~vec)
plot(iris$Petal.Length~vec, col = iris$Species)
vec = runif(nrow(iris), 0, 1)
plot(iris$Petal.Length~vec, col = iris$Species)
vec = runif(nrow(iris), 0, 1)
plot(iris$Petal.Length~vec, col = iris$Species)
m3 = glm(Petal.Length~Sepal.Length*Species+vec, data = iris)
summary(m3)
AIC(m)
age = runif(1000, 1, 20)
hw = log(age)+rnorm(1000,0,.3)
plot(hw~age)
plot(hw~age, las = 1)
plot(hw~age)
plot(hw~age, las = 1)
parasites = 15-10*log(age)+1.5*age+rnorm(1000,0,1)
plot(parasites~age)
m1 = glm(parasites~hw+age)
summary(m1)
plot(parasites~hw)
m2 = glm(parasites~hw+age+I(age^2))
summary(m2)
points(x = hw, y = predict(m1, type = "response"), col = 2)
plot(parasites~hw)
points(x = hw, y = predict(m1, type = "response"), col = age)
import(ggplot2)
package(ggplot2)
library(ggplot2)
ggplot(x = hw, y = predict(m1, type = "response"), color = age)
m3 = glm(parsites~log(age)+age+hw)
m3 = glm(parasites~log(age)+age+hw, data)
m3 = glm(parasites~log(age)+age+hw)
summary(m3)
?pairs
pairs(parasites, age, hw)
n <- 50
x <- y <- 1:n
model <- RMexp(scale=10) + RMnugget(var=1.2)
library(spatstat)
n <- 50
x <- y <- 1:n
model <- RMexp(scale=10) + RMnugget(var=1.2)
library(RandomFields)
n <- 50
x <- y <- 1:n
model <- RMexp(scale=10) + RMnugget(var=1.2)
simu <- RFsimulate(model, x, y)
xsamp <- sample(1:50,400, replace=T)
ysamp <- sample(1:50,400, replace=T)
xsamp2 <- xsamp[!duplicated(data.frame(xsamp, ysamp))]
ysamp2 <- ysamp[!duplicated(data.frame(xsamp, ysamp))]
dat <- c(as.matrix(simu)[cbind(xsamp2, ysamp2)])
dat2 <- data.frame(xsamp2, ysamp2, variable=dat)
library(spatstat)
library(RandomFields)
n <- 50
x <- y <- 1:n
model <- RMexp(scale=10) + RMnugget(var=1.2)
simu <- RFsimulate(model, x, y)
xsamp <- sample(1:50,400, replace=T)
ysamp <- sample(1:50,400, replace=T)
xsamp2 <- xsamp[!duplicated(data.frame(xsamp, ysamp))]
ysamp2 <- ysamp[!duplicated(data.frame(xsamp, ysamp))]
dat <- c(as.matrix(simu)[cbind(xsamp2, ysamp2)])
dat2 <- data.frame(xsamp2, ysamp2, variable=dat)
plot(im(as.matrix(simu), xrange=c(0,50), yrange=c(0,50)))
points(x = dat2$xsamp2, y = dat2$ysamp2)
install.packages("akima")
a = interp(xsamp2, ysamp2, dat2$variable)
?akima
??akima
install.packages("akima")
library(akima)
a = interp(xsamp2, ysamp2, dat2$variable)
View(a)
View(a)
plot(im(as.matrix(a)))
plot(im(as.matrix(a), xrange=c(0,50), yrange=c(0,50)))
plot(im(as.matrix(a$z), xrange=c(0,50), yrange=c(0,50)))
interb = interp(xsamp2, ysamp2, dat2$variable, extrap = T)
plot(im(as.matrix(intera$z), xrange=c(0,50), yrange=c(0,50)))
plot(im(as.matrix(interb$z), xrange=c(0,50), yrange=c(0,50)))
interb = interp(xsamp2, ysamp2, dat2$variable, extrap = T, linear = F)
plot(im(as.matrix(interb$z), xrange=c(0,50), yrange=c(0,50)))
library(spatstat)
library(RandomFields)
n <- 50
x <- y <- 1:n
model <- RMexp(scale=10) + RMnugget(var=1.2)
simu <- RFsimulate(model, x, y)
xsamp <- sample(1:50,400, replace=T)
ysamp <- sample(1:50,400, replace=T)
xsamp2 <- xsamp[!duplicated(data.frame(xsamp, ysamp))]
ysamp2 <- ysamp[!duplicated(data.frame(xsamp, ysamp))]
dat <- c(as.matrix(simu)[cbind(xsamp2, ysamp2)])
dat2 <- data.frame(xsamp2, ysamp2, variable=dat)
plot(im(as.matrix(simu), xrange=c(0,50), yrange=c(0,50)))
points(x = dat2$xsamp2, y = dat2$ysamp2)
library(akima)
intera = interp(xsamp2, ysamp2, dat2$variable)
plot(im(as.matrix(intera$z), xrange=c(0,50), yrange=c(0,50)))
interb = interp(xsamp2, ysamp2, dat2$variable, extrap = T, linear = F)
plot(im(as.matrix(interb$z), xrange=c(0,50), yrange=c(0,50)))
setwd("Documents/Research/IMCapstone/ResultsCSVs/WithPredFlee/endresults")
d = combineFiles(list.files(), c("vig", "lb", "la"), c("Testendresults.txt"),
c("Vigilance","LocalBirth","LearnAlg"))
setwd("../../../RResults")
setwd("Documents/Research/IMCapstone/ResultsCSVs/WithPredFlee/endresults")
setwd("../ResultsCSVs/WithPredFlee/endresults")
library(ggplot2)
library(tidyr)
library(dplyr)
library(gridExtra)
# generates line graphs or bar plots (as applicable) of the results provided based on:
# dtable - data frame of results, with columns for each parameter to split/graph by, and each category of results
# params - vector of column names to split/graph:
#   the lines/bars will be colored based on the last column listed
#   the x-axis will be based on the second to last column listed
#   the data will be split into graphs based on all the other columns (it will create one graph for each combination of values)
# fname - the beginning of the name of all the outputted files
#   it will add on all the names of the parameters split by and their values for each graph
# testvars - list of vectors of column names to plot together (y values) on the same graph
#   can be used to color the graph or for the x-axis if included in params as "category"
# testlabels - vector of labels for the y-axis of each graph, should be the same length as testvars
# catlabels - vector of labels for the colors of each graph, should be the same length as testvars
plotResults = function(dtable, params, fname, testvars, testlabels, catlabels, scatter = F,
linelabels = c(), shapelabels = c(), savelv = 2){
if(length(params) == savelv){
# loop through each set of measures to crete the corresponding plots
for(v in 1:length(testvars)) {
# format the data for ggplot
plotd = gather(dtable, category, measure, testvars[[v]])
# make sure nothing is infinite
is.na(plotd) = sapply(plotd, is.infinite)
# grab the x axis variable for convenience
plotd$x = plotd[, params[length(params)-1]]
# split the category to see if there are actually multiple
cats = strsplit(params[length(params)], " ")[[1]]
# the category can be split by color
plotd$c = ""
# by shape
plotd$s = ""
# and by linetype
plotd$l = ""
# I'm going to have an index here to increment
j = 1
# if the data is going to be split into shapes, use the first category for that
if(length(shapelabels) > 0){
plotd$s = factor(plotd[, cats[1]])
j = j+1
# also, if there's only one shape label given use that
if(length(shapelabels) == 1){
slab = shapelabels[1]
} else {
# otherwise, use the label corresponding to this test variable
slab = shapelabels[v]
}
} else {
slab = ""
}
# if there are more categories left and this is going to be split into linetypes, do so
if(length(cats) >= j & length(linelabels) > 0){
plotd$l = factor(plotd[, cats[j]])
j = j+1
# also set the line label
if(length(linelabels) == 1){
llab = linelabels[1]
} else {
llab = linelables[v]
}
} else {
llab = ""
}
# if there are more categories left, combine them for use as the color
if(length(cats) >= j) {
for(i in j:length(cats)){
plotd$c = paste(plotd$c, plotd[, cats[i]])
}
# also set the color label
if(length(catlabels) == 1){
clab = catlabels[1]
} else {
clab = catlables[v]
}
} else {
clab = ""
}
# turn the color into a factor
plotd$c = factor(plotd$c)
# if this isn't a scatter plot average the relevant measures so there aren't duplicates
if(!scatter){
plotd = summarize(group_by(group_by_at(plotd, params[1:(length(params)-2)]), x, c, s, l, add = T),
N = length(measure), mean = mean(measure, na.rm = T),
sd = sd(measure, na.rm = T), se = sd / sqrt(N))
plotd = as.data.frame(plotd)
}
# plot the results
# create a scatter plot if scatter is true
if(scatter){
plot = ggplot(plotd, aes(x = x, y = measure, colour = c)) + geom_point(aes(shape = s)) +
ylab(testlabels[v]) + xlab(params[length(params)-1]) + labs(colour = params[length(params)]) +
guides(colour=guide_legend(title=clab), shape=guide_legend(title=slab)) +
geom_smooth(method = 'lm', se = F)
} else if(is.numeric(plotd$x)){
# otherwise, if the x-axis is numeric, turn this into a linegraph
plot = ggplot(plotd, aes(x = x, y = mean, colour = c)) +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.1) + geom_line(aes(linetype = l)) +
geom_point(aes(shape = s, size = N/sum(N))) + ylab(testlabels[v]) + xlab(params[length(params)-1]) +
labs(colour = params[length(params)]) +
guides(colour=guide_legend(title=clab), shape=guide_legend(title=slab), linetype=guide_legend(title = llab))
} else {
# otherwise, turn it into a bargraph
plot = ggplot(plotd, aes(x = x, y = mean, fill = c)) +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.2, position=position_dodge(.9)) +
geom_bar(stat = "identity", position = "dodge") + ylab(testlabels[v]) + xlab(params[length(params)-1]) +
labs(fill = params[length(params)]) + guides(fill=guide_legend(title=clab))
}
# if the save level is higher than 2, make a grid of grids for all the remaining parameters
# if the save level is 3, just make a single row
if(savelv == 3){
plot = plot + facet_grid(cols = vars(plotd[, params[(length(params)-2)]]))
} else if (savelv > 3) {
# otherwise, make a grid from the last two parameters
plot = plot + facet_grid(rows = vars(plotd[, params[(length(params)-2)]]),
cols = vars(plotd[, params[(length(params)-3)]]))
}
ggsave(paste(fname, testlabels[v], ".png", sep = ""), plot = plot)
}
} else {
# otherwise, recurse on all values of this parameter
for(v in unique(dtable[, params[1]])){
# update the filename to pass it
f = paste(fname, params[1], v, sep = "")
# get the corresponding plot/grid of plots
plotResults(dtable[dtable[, params[1]] == v, ], params[-1], f, testvars, testlabels, catlabels,
scatter, linelabels = linelabels, shapelabels = shapelabels, savelv = savelv)
}
}
}
library(stringr)
combineFiles = function(fnames, paramIDs, endstrings, paramnames){
dtable = data.frame()
for(f in 1:length(fnames)){
if(substring(fnames[f], nchar(fnames[f])-3) == ".txt"){
d = read.table(fnames[f], header = TRUE, comment.char = "%", sep = "\t")
# find all the params and endstrings
splits = unlist(str_locate_all(fnames[f], c(paramIDs, endstrings)))
# store the starts and ends separately
starts = splits[c(T, F)]
ends = splits[c(F, T)]
# get the order of all the splits
splitorder = order(starts)
# loop through all the splits in order
for(s in 1:length(splitorder)){
# only use it if it's actually a parameter, not just an end string
if(splitorder[s] < length(paramnames)+1){
# grab the value between the end of this split and the beginning of the next
val = substr(fnames[f], ends[splitorder[s]]+1, starts[splitorder[s+1]]-1)
if(!is.na(as.numeric(val))) { val = as.numeric(val) }
# create a new column with the designated name and value
d[, paramnames[splitorder[s]]] = val
}
}
# now merge this dataframe with the previous
dtable = rbind(dtable, d)
}
}
# return the complete table
return(dtable)
}
d = combineFiles(list.files(), c("vig", "lb", "la"), c("Testendresults.txt"),
c("Vigilance","LocalBirth","LearnAlg"))
d2 = gather(d, type, count, c("vigcount", "indcount", "soccount"))
d2$type[d2$type == "vigcount"] = "vigilance"
d2$type[d2$type == "indcount"] = "individual"
d2$type[d2$type == "soccount"] = "social"
d2$alarm[d2$type == "vigilance"] = d2$VigAlarm[d2$type == "vigilance"]
d2$alarm[d2$type == "individual"] = d2$IndAlarm[d2$type == "individual"]
d2$alarm[d2$type == "social"] = d2$SocAlarm[d2$type == "social"]
d2$noalarm[d2$type == "vigilance"] = d2$VigNoAlarm[d2$type == "vigilance"]
d2$noalarm[d2$type == "individual"] = d2$IndNoAlarm[d2$type == "individual"]
d2$noalarm[d2$type == "social"] = d2$SocNoAlarm[d2$type == "social"]
d2$predcost[d2$type == "vigilance"] = d2$VigPredCost[d2$type == "vigilance"]
d2$predcost[d2$type == "individual"] = d2$IndPredCost[d2$type == "individual"]
d2$predcost[d2$type == "social"] = d2$SocPredCost[d2$type == "social"]
d2$foragecost[d2$type == "vigilance"] = d2$VigForageCost[d2$type == "vigilance"]
d2$foragecost[d2$type == "individual"] = d2$IndForageCost[d2$type == "individual"]
d2$foragecost[d2$type == "social"] = d2$SocForageCost[d2$type == "social"]
d2$offspring[d2$type == "vigilance"] = d2$VigOffspring[d2$type == "vigilance"]
d2$offspring[d2$type == "individual"] = d2$IndOffspring[d2$type == "individual"]
d2$offspring[d2$type == "social"] = d2$SocOffspring[d2$type == "social"]
d2$lifespan[d2$type == "vigilance"] = d2$VigLifespan[d2$type == "vigilance"]
d2$lifespan[d2$type == "individual"] = d2$IndLifespan[d2$type == "individual"]
d2$lifespan[d2$type == "social"] = d2$SocLifespan[d2$type == "social"]
d6 = d[d$LearnAlg != 'b' & d$Vigilance == "true" & d$vigcount < d$indcount+d$soccount, ]
# I'm going to add log hunsteps, which will be more meaningful
d6$loghuntsteps = log(d6$huntsteps)
summary(d6)
d7 = gather(d6, type, count, c("vigcount", "indcount", "soccount"))
d7$type[d7$type == "vigcount"] = "vigilance"
d7$type[d7$type == "indcount"] = "individual"
d7$type[d7$type == "soccount"] = "social"
d4 = d[d$LearnAlg != 'b' & d$Vigilance == "true",]
d4$SocProp = d4$soccount/(d4$soccount + d4$vigcount + d4$indcount)
d4$VigProp = d4$vigcount/(d4$soccount + d4$vigcount + d4$indcount)
# log huntsteps will be more informative when it's used on the x-axis
d4$loghuntsteps = log(d4$huntsteps)
# three parameters
plotResults(d4, c("predfreq", "stayforage", "foragediff"), "predfreq stayforage foragediff", list(c("VigProp")), c("Proportion of Vigilance Only"), catlabels = "forage diff", savelv = 3)
setwd("../../../RResults")
# three parameters
plotResults(d4, c("huntsteps", "predflee", "foragediff"), "huntsteps predflee foragediff", list(c("VigProp")), c("Proportion of Vigilance Only"), catlabels = "forage diff", savelv = 3)
# three parameters
plotResults(d4, c("predfreq", "huntsteps", "stayforage", "foragediff"), "predfreq huntsteps stayforage foragediff", list(c("VigProp")), c("Proportion of Vigilance Only"), catlabels = "forage diff", savelv = 4)
# three parameters
plotResults(d4, c("huntsteps", "predfreq", "stayforage", "foragediff"), "huntsteps predfreq stayforage foragediff", list(c("VigProp")), c("Proportion of Vigilance Only"), catlabels = "forage diff", savelv = 4)
testparams = c("LocalBirth", "loghuntsteps", "predflee", "stayforage", "predfreq", "LearnAlg")
for(p in testparams){
plotResults(d7, c("foragediff", p, "type"), paste("foragediff", p), list(c("count")), c("Surviving"), catlabels = "Genotype", savelv = 3)
}
summary(d7)
# a quick inspection of the cases where vigilance doesn't dominate
#d6 = d[d$LearnAlg != 'b' & d$Vigilance == "true" & d$vigcount < d$indcount+d$soccount, ]
d6 = d[d$LearnAlg != 'b' & d$Vigilance == "true"]
# a quick inspection of the cases where vigilance doesn't dominate
#d6 = d[d$LearnAlg != 'b' & d$Vigilance == "true" & d$vigcount < d$indcount+d$soccount, ]
d6 = d[d$LearnAlg != 'b' & d$Vigilance == "true", ]
d6$loghuntsteps = log(d6$huntsteps)
#summary(d6)
d7 = gather(d6, type, count, c("vigcount", "indcount", "soccount"))
d7$type[d7$type == "vigcount"] = "vigilance"
d7$type[d7$type == "indcount"] = "individual"
d7$type[d7$type == "soccount"] = "social"
testparams = c("LocalBirth", "loghuntsteps", "predflee", "stayforage", "predfreq", "LearnAlg")
for(p in testparams){
plotResults(d7, c("foragediff", p, "type"), paste("foragediff", p), list(c("count")), c("Surviving"), catlabels = "Genotype", savelv = 3)
}
testparams = c("LocalBirth", "loghuntsteps", "predflee", "stayforage", "foragediff", "LearnAlg")
for(p in testparams){
plotResults(d7, c("predfreq", p, "type"), paste("predfreq", p), list(c("count")), c("Surviving"), catlabels = "Genotype", savelv = 3)
}
setwd("../ResultsCSVs")
learnd = read.table("learntesttimeresults.txt", header = TRUE, comment.char = "%", sep = "\t")
d2 = gather(learnd, type, count, c("vigcount", "indcount", "soccount"))
d2$type[d2$type == "vigcount"] = "vigilance"
d2$type[d2$type == "indcount"] = "individual"
d2$type[d2$type == "soccount"] = "social"
d2$alarm[d2$type == "vigilance"] = d2$VigAlarm[d2$type == "vigilance"]
d2$alarm[d2$type == "individual"] = d2$IndAlarm[d2$type == "individual"]
d2$alarm[d2$type == "social"] = d2$SocAlarm[d2$type == "social"]
d2$noalarm[d2$type == "vigilance"] = d2$VigNoAlarm[d2$type == "vigilance"]
d2$noalarm[d2$type == "individual"] = d2$IndNoAlarm[d2$type == "individual"]
d2$noalarm[d2$type == "social"] = d2$SocNoAlarm[d2$type == "social"]
d2$predcost[d2$type == "vigilance"] = d2$VigPredCost[d2$type == "vigilance"]
d2$predcost[d2$type == "individual"] = d2$IndPredCost[d2$type == "individual"]
d2$predcost[d2$type == "social"] = d2$SocPredCost[d2$type == "social"]
d2$foragecost[d2$type == "vigilance"] = d2$VigForageCost[d2$type == "vigilance"]
d2$foragecost[d2$type == "individual"] = d2$IndForageCost[d2$type == "individual"]
d2$foragecost[d2$type == "social"] = d2$SocForageCost[d2$type == "social"]
d2$offspring[d2$type == "vigilance"] = d2$VigOffspring[d2$type == "vigilance"]
d2$offspring[d2$type == "individual"] = d2$IndOffspring[d2$type == "individual"]
d2$offspring[d2$type == "social"] = d2$SocOffspring[d2$type == "social"]
d2$lifespan[d2$type == "vigilance"] = d2$VigLifespan[d2$type == "vigilance"]
d2$lifespan[d2$type == "individual"] = d2$IndLifespan[d2$type == "individual"]
d2$lifespan[d2$type == "social"] = d2$SocLifespan[d2$type == "social"]
plotResults(d2, c("LearnAlg", "lrate", "Timestep", "type"), "", list(c("alarm"), c("noalarm")), c("Response to Alarm", "Response to No Alarm"), c("Genotype"), savelv = 4)
View(d2)
plotResults(d2, c("learnalg", "lrate", "Timestep", "type"), "", list(c("alarm"), c("noalarm")), c("Response to Alarm", "Response to No Alarm"), c("Genotype"), savelv = 4)
library(ggplot2)
library(tidyr)
library(dplyr)
library(gridExtra)
# generates line graphs or bar plots (as applicable) of the results provided based on:
# dtable - data frame of results, with columns for each parameter to split/graph by, and each category of results
# params - vector of column names to split/graph:
#   the lines/bars will be colored based on the last column listed
#   the x-axis will be based on the second to last column listed
#   the data will be split into graphs based on all the other columns (it will create one graph for each combination of values)
# fname - the beginning of the name of all the outputted files
#   it will add on all the names of the parameters split by and their values for each graph
# testvars - list of vectors of column names to plot together (y values) on the same graph
#   can be used to color the graph or for the x-axis if included in params as "category"
# testlabels - vector of labels for the y-axis of each graph, should be the same length as testvars
# catlabels - vector of labels for the colors of each graph, should be the same length as testvars
plotResults = function(dtable, params, fname, testvars, testlabels, catlabels, scatter = F,
linelabels = c(), shapelabels = c(), savelv = 2, pointsize = F){
if(length(params) == savelv){
# loop through each set of measures to crete the corresponding plots
for(v in 1:length(testvars)) {
# format the data for ggplot
plotd = gather(dtable, category, measure, testvars[[v]])
# make sure nothing is infinite
is.na(plotd) = sapply(plotd, is.infinite)
# grab the x axis variable for convenience
plotd$x = plotd[, params[length(params)-1]]
# split the category to see if there are actually multiple
cats = strsplit(params[length(params)], " ")[[1]]
# the category can be split by color
plotd$c = ""
# by shape
plotd$s = ""
# and by linetype
plotd$l = ""
# I'm going to have an index here to increment
j = 1
# if the data is going to be split into shapes, use the first category for that
if(length(shapelabels) > 0){
plotd$s = factor(plotd[, cats[1]])
j = j+1
# also, if there's only one shape label given use that
if(length(shapelabels) == 1){
slab = shapelabels[1]
} else {
# otherwise, use the label corresponding to this test variable
slab = shapelabels[v]
}
} else {
slab = ""
}
# if there are more categories left and this is going to be split into linetypes, do so
if(length(cats) >= j & length(linelabels) > 0){
plotd$l = factor(plotd[, cats[j]])
j = j+1
# also set the line label
if(length(linelabels) == 1){
llab = linelabels[1]
} else {
llab = linelables[v]
}
} else {
llab = ""
}
# if there are more categories left, combine them for use as the color
if(length(cats) >= j) {
for(i in j:length(cats)){
plotd$c = paste(plotd$c, plotd[, cats[i]])
}
# also set the color label
if(length(catlabels) == 1){
clab = catlabels[1]
} else {
clab = catlables[v]
}
} else {
clab = ""
}
# turn the color into a factor
plotd$c = factor(plotd$c)
# if this isn't a scatter plot average the relevant measures so there aren't duplicates
if(!scatter){
plotd = summarize(group_by(group_by_at(plotd, params[1:(length(params)-2)]), x, c, s, l, add = T),
N = length(measure), mean = mean(measure, na.rm = T),
sd = sd(measure, na.rm = T), se = sd / sqrt(N))
plotd = as.data.frame(plotd)
}
# plot the results
# create a scatter plot if scatter is true
if(scatter){
plot = ggplot(plotd, aes(x = x, y = measure, colour = c)) + geom_point(aes(shape = s)) +
ylab(testlabels[v]) + xlab(params[length(params)-1]) + labs(colour = params[length(params)]) +
guides(colour=guide_legend(title=clab), shape=guide_legend(title=slab)) +
geom_smooth(method = 'lm', se = F)
} else if(is.numeric(plotd$x)){
# otherwise, if the x-axis is numeric, turn this into a linegraph
plot = ggplot(plotd, aes(x = x, y = mean, colour = c)) +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.1) + geom_line(aes(linetype = l)) +
geom_point(aes(shape = s)) + ylab(testlabels[v]) + xlab(params[length(params)-1]) +
labs(colour = params[length(params)]) +
guides(colour=guide_legend(title=clab), shape=guide_legend(title=slab), linetype=guide_legend(title = llab))
} else {
# otherwise, turn it into a bargraph
plot = ggplot(plotd, aes(x = x, y = mean, fill = c)) +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.2, position=position_dodge(.9)) +
geom_bar(stat = "identity", position = "dodge") + ylab(testlabels[v]) + xlab(params[length(params)-1]) +
labs(fill = params[length(params)]) + guides(fill=guide_legend(title=clab))
}
# if the save level is higher than 2, make a grid of grids for all the remaining parameters
# if the save level is 3, just make a single row
if(savelv == 3){
plot = plot + facet_grid(cols = vars(plotd[, params[(length(params)-2)]]))
} else if (savelv > 3) {
# otherwise, make a grid from the last two parameters
plot = plot + facet_grid(rows = vars(plotd[, params[(length(params)-2)]]),
cols = vars(plotd[, params[(length(params)-3)]]))
}
ggsave(paste(fname, testlabels[v], ".png", sep = ""), plot = plot)
}
} else {
# otherwise, recurse on all values of this parameter
for(v in unique(dtable[, params[1]])){
# update the filename to pass it
f = paste(fname, params[1], v, sep = "")
# get the corresponding plot/grid of plots
plotResults(dtable[dtable[, params[1]] == v, ], params[-1], f, testvars, testlabels, catlabels,
scatter, linelabels = linelabels, shapelabels = shapelabels, savelv = savelv)
}
}
}
plotResults(d2, c("learnalg", "lrate", "Timestep", "type"), "", list(c("alarm"), c("noalarm")), c("Response to Alarm", "Response to No Alarm"), c("Genotype"), savelv = 4)
