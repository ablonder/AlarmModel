source('~/Documents/Research/IMCapstone/analyzeAlarm.R', echo=TRUE)
source('~/Documents/Research/IMCapstone/analyzeAlarm.R', echo=TRUE)
source('~/Documents/Research/IMCapstone/analyzeAlarm.R', echo=TRUE)
library(ggplot2)
library(tidyr)
library(dplyr)
library(gridExtra)
# generates line graphs or bar plots (as applicable) of the results provided based on:
# dtable - data frame of results, with columns for each parameter to split/graph by, and each category of results
# params - vector of column names to split/graph:
#   the lines/bars will be colored based on the last column listed
#   the x-axis will be based on the second to last column listed
#   the data will be split into graphs based on all the other columns (it will create one graph for each combination of values)
# fname - the beginning of the name of all the outputted files
#   it will add on all the names of the parameters split by and their values for each graph
# testvars - list of vectors of column names to plot together (y values) on the same graph
#   can be used to color the graph or for the x-axis if included in params as "category"
# testlabels - vector of labels for the y-axis of each graph, should be the same length as testvars
# catlabels - vector of labels for the colors of each graph, should be the same length as testvars
plotResults = function(dtable, params, fname, testvars, testlabels, catlabels, scatter = F,
linelabels = c(), shapelabels = c(), savelv = 2){
if(length(params) == savelv){
# loop through each set of measures to crete the corresponding plots
for(v in 1:length(testvars)) {
# format the data for ggplot
plotd = gather(dtable, category, measure, testvars[[v]])
# make sure nothing is infinite
is.na(plotd) = sapply(plotd, is.infinite)
# grab the x axis variable for convenience
plotd$x = plotd[, params[length(params)-1]]
# split the category to see if there are actually multiple
cats = strsplit(params[length(params)], " ")[[1]]
# the category can be split by color
plotd$c = ""
# by shape
plotd$s = ""
# and by linetype
plotd$l = ""
# I'm going to have an index here to increment
j = 1
# if the data is going to be split into shapes, use the first category for that
if(length(shapelabels) > 0){
plotd$s = factor(plotd[, cats[1]])
j = j+1
# also, if there's only one shape label given use that
if(length(shapelabels) == 1){
slab = shapelabels[1]
} else {
# otherwise, use the label corresponding to this test variable
slab = shapelabels[v]
}
} else {
slab = ""
}
# if there are more categories left and this is going to be split into linetypes, do so
if(length(cats) >= j & length(linelabels) > 0){
plotd$l = factor(plotd[, cats[j]])
j = j+1
# also set the line label
if(length(linelabels) == 1){
llab = linelabels[1]
} else {
llab = linelables[v]
}
} else {
llab = ""
}
# if there are more categories left, combine them for use as the color
if(length(cats) >= j) {
for(i in j:length(cats)){
plotd$c = paste(plotd$c, plotd[, cats[i]])
}
# also set the color label
if(length(catlabels) == 1){
clab = catlabels[1]
} else {
clab = catlables[v]
}
} else {
clab = ""
}
# turn the color into a factor
plotd$c = factor(plotd$c)
# if this isn't a scatter plot average the relevant measures so there aren't duplicates
if(!scatter){
plotd = summarize(group_by(group_by_at(plotd, params[1:(length(params)-2)]), x, c, s, l, add = T),
N = length(measure), mean = mean(measure, na.rm = T),
sd = sd(measure, na.rm = T), se = sd / sqrt(N))
plotd = as.data.frame(plotd)
}
# plot the results
# create a scatter plot if scatter is true
if(scatter){
plot = ggplot(plotd, aes(x = x, y = measure, colour = c)) + geom_point(aes(shape = s)) +
ylab(testlabels[v]) + xlab(params[length(params)-1]) + labs(colour = params[length(params)]) +
guides(colour=guide_legend(title=clab), shape=guide_legend(title=slab)) +
geom_smooth(method = 'lm', se = F)
} else if(is.numeric(plotd$x)){
# otherwise, if the x-axis is numeric, turn this into a linegraph
plot = ggplot(plotd, aes(x = x, y = mean, colour = c)) +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.1) + geom_line(aes(linetype = l)) +
geom_point(aes(shape = s)) + ylab(testlabels[v]) + xlab(params[length(params)-1]) +
labs(colour = params[length(params)]) +
guides(colour=guide_legend(title=clab), shape=guide_legend(title=slab), linetype=guide_legend(title = llab))
} else {
# otherwise, turn it into a bargraph
plot = ggplot(plotd, aes(x = x, y = mean, fill = c)) +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.2, position=position_dodge(.9)) +
geom_bar(stat = "identity", position = "dodge") + ylab(testlabels[v]) + xlab(params[length(params)-1]) +
labs(fill = params[length(params)]) + guides(fill=guide_legend(title=clab))
}
# if the save level is higher than 2, make a grid of grids for all the remaining parameters
# if the save level is 3, just make a single row
if(savelv == 3){
plot = plot + facet_grid(cols = vars(plotd[, params[(length(params)-2)]]))
} else if (savelv > 3) {
# otherwise, make a grid from the last two parameters
plot = plot + facet_grid(rows = vars(plotd[, params[(length(params)-2)]]),
cols = vars(plotd[, params[(length(params)-3)]]))
}
ggsave(paste(fname, testlabels[v], ".png", sep = ""), plot = plot)
}
} else {
# otherwise, recurse on all values of this parameter
for(v in unique(dtable[, params[1]])){
# update the filename to pass it
f = paste(fname, params[1], v, sep = "")
# get the corresponding plot/grid of plots
plotResults(dtable[dtable[, params[1]] == v, ], params[-1], f, testvars, testlabels, catlabels,
scatter, linelabels = linelabels, shapelabels = shapelabels, savelv = savelv)
}
}
}
install.packages("gridExtra")
library(gridExtra)
library(ggplot2)
library(tidyr)
setwd("Documents/Research/IMCapstone/ResultsCSVs/WithPredFlee/endresults")
setwd("../ResultsCSVs/WithPredFlee/EndResults")
d = combineFiles(list.files(), c("vig", "lb", "la"), c("Testendresults.txt"),
c("Vigilance","LocalBirth","LearnAlg"))
setwd("../../../RResults")
d2 = gather(d, type, count, c("vigcount", "indcount", "soccount"))
d2$type[d2$type == "vigcount"] = "vigilance"
d2$type[d2$type == "indcount"] = "individual"
d2$type[d2$type == "soccount"] = "social"
d2$alarm[d2$type == "vigilance"] = d2$VigAlarm[d2$type == "vigilance"]
d2$alarm[d2$type == "individual"] = d2$IndAlarm[d2$type == "individual"]
d2$alarm[d2$type == "social"] = d2$SocAlarm[d2$type == "social"]
d2$noalarm[d2$type == "vigilance"] = d2$VigNoAlarm[d2$type == "vigilance"]
d2$noalarm[d2$type == "individual"] = d2$IndNoAlarm[d2$type == "individual"]
d2$noalarm[d2$type == "social"] = d2$SocNoAlarm[d2$type == "social"]
d2$predcost[d2$type == "vigilance"] = d2$VigPredCost[d2$type == "vigilance"]
d2$predcost[d2$type == "individual"] = d2$IndPredCost[d2$type == "individual"]
d2$predcost[d2$type == "social"] = d2$SocPredCost[d2$type == "social"]
d2$foragecost[d2$type == "vigilance"] = d2$VigForageCost[d2$type == "vigilance"]
d2$foragecost[d2$type == "individual"] = d2$IndForageCost[d2$type == "individual"]
d2$foragecost[d2$type == "social"] = d2$SocForageCost[d2$type == "social"]
d2$offspring[d2$type == "vigilance"] = d2$VigOffspring[d2$type == "vigilance"]
d2$offspring[d2$type == "individual"] = d2$IndOffspring[d2$type == "individual"]
d2$offspring[d2$type == "social"] = d2$SocOffspring[d2$type == "social"]
d2$lifespan[d2$type == "vigilance"] = d2$VigLifespan[d2$type == "vigilance"]
d2$lifespan[d2$type == "individual"] = d2$IndLifespan[d2$type == "individual"]
d2$lifespan[d2$type == "social"] = d2$SocLifespan[d2$type == "social"]
plotResults(d2[d2$predfreq == .1 & d2$stayforage == 1, ], c("Vigilance", "LocalBirth", "huntsteps", "fleeforage", "noalarm", "LearnAlg type"), "realtestNoAlarm",
list(c("count")), c("Survivng Agents"), c("Genotype"), scatter = T, shapelabels = c("Learning Algorithm"), savelv = 4)
plotResults(d2[d2$predfreq == .1 & d2$stayforage == 1, ], c("Vigilance", "LocalBirth", "huntsteps", "fleeforage", "type", "LearnAlg"), "realtestForageCost",
list(c("foragecost")), c("Cost from Foraging"), c("Learning Algorithm"), scatter = F, savelv = 4)
plotResults(d2, c("Vigilance", "LocalBirth", "huntsteps", "predflee", "stayforage", "predfreq", "LearnAlg LearnAlg type"), "fleeforage0",
list(c("alarm"), c("noalarm")), c("Response to Alarm", "Response to the Absence of an Alarm"), c("Genotype"), linelabels = c("Learning Algorithm"), shapelabels = c("Learning Algorithm"), savelv = 4)
plotResults(d2, c("Vigilance", "LocalBirth", "stayforage", "huntsteps", "predflee", "foragediff", "predfreq", "LearnAlg LearnAlg type"), "",
list(c("count")), c("Surviving Agents"), c("Genotype"), linelabels = c("Learning Algorithm"), shapelabels = c("Learning Algorithm"), savelv = 4)
ggplot(d2, aes(x = lifespan, fill = type, color = type)) +
geom_histogram(bins = 50, position = "identity", alpha = .5)
d3 = d
d3$AlarmDiff = d3$SocAlarm - d3$IndAlarm
d3$NoAlarmDiff = d3$IndNoAlarm - d3$SocNoAlarm
ggplot(d3, aes(x = NoAlarmDiff, fill = LearnAlg, color = LearnAlg)) +
geom_histogram(binwidth = .01, alpha = .5, position = "identity")
d4 = d[d$LearnAlg != 'b',]
d4$SocProp = d4$soccount/(d4$soccount + d4$vigcount + d4$indcount)
testparams = c("Vigilance", "LocalBirth", "huntsteps", "predflee", "stayforage", "foragediff", "predfreq", "LearnAlg")
for(p in testparams){
d4[,p] = as.factor(d4[,p])
plot = ggplot(d4, aes(x = d4[, p], y = SocProp)) + geom_boxplot() + xlab(p)
ggsave(paste(p, ".png"))
}
for(p1 in testparams){
for(p2 in testparams){
if(p1 != p2){
plotResults(d4, c(p1, p2), paste(p1, p2), list(c("SocProp")), c("Proportion of Social Learners"), catlabels = p2)
}
}
}
library(stringr)
combineFiles = function(fnames, paramIDs, endstrings, paramnames){
dtable = data.frame()
for(f in 1:length(fnames)){
d = read.table(fnames[f], header = TRUE, comment.char = "%", sep = "\t")
# find all the params and endstrings
splits = unlist(str_locate_all(fnames[f], c(paramIDs, endstrings)))
# store the starts and ends separately
starts = splits[c(T, F)]
ends = splits[c(F, T)]
# get the order of all the splits
splitorder = order(starts)
# loop through all the splits in order
for(s in 1:length(splitorder)){
# only use it if it's actually a parameter, not just an end string
if(splitorder[s] < length(paramnames)+1){
# grab the value between the end of this split and the beginning of the next
val = substr(fnames[f], ends[splitorder[s]]+1, starts[splitorder[s+1]]-1)
if(!is.na(as.numeric(val))) { val = as.numeric(val) }
# create a new column with the designated name and value
d[, paramnames[splitorder[s]]] = val
}
}
# now merge this dataframe with the previous
dtable = rbind(dtable, d)
}
# return the complete table
return(dtable)
}
library(ggplot2)
library(tidyr)
setwd("Documents/Research/IMCapstone/ResultsCSVs/WithPredFlee/endresults")
d = combineFiles(list.files(), c("vig", "lb", "la"), c("Testendresults.txt"),
c("Vigilance","LocalBirth","LearnAlg"))
setwd("../ResultsCSVs/WithPredFlee/EndResults")
getwd()
setwd("ResultsCSVs/WithPredFlee/EndResults")
setwd("/ResultsCSVs/WithPredFlee/EndResults")
setwd("/ResultsCSVs/WithPredFlee/endresults")
setwd("ResultsCSVs/WithPredFlee/endresults")
d = combineFiles(list.files(), c("vig", "lb", "la"), c("Testendresults.txt"),
c("Vigilance","LocalBirth","LearnAlg"))
setwd("../../../RResults")
d4 = d[d$LearnAlg != 'b',]
d4$SocProp = d4$soccount/(d4$soccount + d4$vigcount + d4$indcount)
# three parameters
plotResults(d4, c("predfreq", "predflee", "huntsteps"), "", list(c"SocProp"), c("Proportion of Social Learners"), catlabels = "huntsteps")
# three parameters
plotResults(d4, c("predfreq", "predflee", "huntsteps"), "", list(c("SocProp")), c("Proportion of Social Learners"), catlabels = "huntsteps")
# three parameters
plotResults(d4, c("predfreq", "predflee", "huntsteps"), "predfreq predflee huntsteps", list(c("SocProp")), c("Proportion of Social Learners"), catlabels = "huntsteps", savelv = 3)
# three parameters
plotResults(d4, c("LocalBirth", "predfreq", "huntsteps"), "localbirth predfreq huntsteps", list(c("SocProp")), c("Proportion of Social Learners"), catlabels = "huntsteps", savelv = 3)
