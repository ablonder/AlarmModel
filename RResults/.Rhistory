title: "Lab 4 Homework"
author: "Aviva Blonder"
date: "October 16, 2019"
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
First, I'm going to simulate some data according to the following model:
$${y_i} =  3 - 4 \cdot {x_i} + {\varepsilon _i}$$
$${\varepsilon _i}\sim \mathcal{N}\left( {\mu  = 0,\sigma} \right)$$
I'm going to have to draw a few different data sets with different values of sigma, so I'll start by making a function that does that for me.
```{r simdata}
simdata = function(sigma){
# first draw x values from a uniform distribution (number and interval doesn't matter)
x = runif(1000, 0, 10)
# now draw values of epsilon from the normal distribution
e = rnorm(1000, 0, sigma)
# and bring them together to get y values
y = 3 - 4*x + e
# return x and y
return(data.frame(x, y))
}
```
I can use my function to create five datasets with $\sigma=.5$, $\sigma=1$, $\sigma=3$, $\sigma=5$, and $\sigma=10$ respectively.
```{r}
d1 = simdata(.5)
d2 = simdata(1)
d3 = simdata(3)
d4 = simdata(5)
d5 = simdata(10)
```
Now that I have the data, I can fit a GLM to each dataset (using the built-in R function).
```{r}
m1 = glm(y~x, data = d1, family = "gaussian")
m2 = glm(y~x, data = d2, family = "gaussian")
m3 = glm(y~x, data = d3, family = "gaussian")
m4 = glm(y~x, data = d4, family = "gaussian")
m5 = glm(y~x, data = d5, family = "gaussian")
```
For each dataset, I'll also calculate the loglikelihood for $- 10 \le b \le 10$ to create a probability density plot. Again, I'll start by creating a function that does it for me.
```{r}
densityplot = function(data, sigma){
# start by creating a list of b values
b = seq(-10, 10, .01)
# then create an array to hold the results
res = rep(0, length(b))
# loop through values of b from -10 to 10 and calculate the likelihood of the data
for(i in 1:length(b)){
# calculate the error based for this value of b
error = data$y - (3-b[i]*data$x)
# get the loglikelihood of the error based on the normal distribution it was drawn from
density = dnorm(x=error, mean=0, sd=sigma, log=T)
# add all the data points together and add them to the array
res[i] = sum(density)
}
# at the end, return the results
return(res)
}
```
Now I'll get the likelihood curve for each dataset and plot them all.
```{r}
# run the funciton to get the data
p1 = densityplot(d1, .5)
p2 = densityplot(d2, 1)
p3 = densityplot(d3, 3)
p4 = densityplot(d4, 5)
p5 = densityplot(d5, 10)
# get some colors
r = rainbow(5)
# now I can use them to plot
plot(x=seq(-10,10,.01), y=p1, type="l", col=r[1], xlab="Value of b", ylab="LogLikelihood")
lines(x=seq(-10,10,.01), y=p2, col=r[2])
lines(x=seq(-10,10,.01), y=p3, col=r[3])
lines(x=seq(-10,10,.01), y=p4, col=r[4])
lines(x=seq(-10,10,.01), y=p5, col=r[5])
legend(4.5, y = -7000000, legend = c("sigma = .5", "sigma = 1", "sigma = 3", "sigma = 5", "sigma = 10"), lty = 1, col = r)
```
The curve for $\sigma = .5$ is the most "peaky" because it has the least error or deviation from the mean, which makes it more obvious what the true parameter values are. As $\sigma$ increases, the relationship between x and y becomes less clear, so, just based on the data, it becomes equally likely for the parameters to have any of a range of values, even though the standard deviation of the error is known.
knitr::opts_chunk$set(echo = TRUE)
m1
install.packages("coin")
iris
head(iris)
plot(iris$Petal.Length~iris$Petal.Length+iris$Species)
plot(iris$Petal.Length~iris$Petal.Width+iris$Species)
plot(iris$Petal.Length~iris$Petal.Width*iris$Species)
plot(iris$Petal.Length~iris$Petal.Width, col=Species)
plot(iris$Petal.Length~iris$Petal.Width, col=iris$Species)
lm(iris$Petal.Length~iris$Petal.Width*iris$Species)
m1 = lm(iris$Petal.Length~iris$Petal.Width*iris$Species)
summary(m1)
m2 = lm(iris$Petal.Length~iris$Petal.Width+iris$Species)
summary(m2)
points(iris$Petal.Width, predict(m1), col = iris$Species)
points(iris$Petal.Width, predict(m1), col = iris$Species, type = "l")
points(iris$Petal.Width, predict(m1), col = iris$Species, pch = 16, type = "l")
points(iris$Petal.Width, predict(m1), col = iris$Species, pch = 16)
points(iris$Petal.Width, predict(m1), col = iris$Species, pch = 16)
plot(iris$Petal.Length~iris$Petal.Width, col=iris$Species)
points(iris$Petal.Width, predict(m1), col = iris$Species, pch = 16)
points(iris$Petal.Width, predict(m2), col = iris$Species, pch = 16)
plot(iris$Petal.Length~iris$Petal.Width, col=iris$Species)
points(iris$Petal.Width, predict(m2), col = iris$Species, pch = 16)
plot(iris$Petal.Length~iris$Petal.Width, col=iris$Species)
points(iris$Petal.Width, predict(m1), col = iris$Species, pch = 16)
m3 = lm(iris$Petal.Length~iris$Petal.Width:iris$Species)
summary(m3)
plot(iris$Petal.Length~iris$Petal.Width, col=iris$Species)
points(iris$Petal.Width, predict(m3), col = iris$Species, pch = 16)
library(lme4)
library(lmerTest)
mixed.pval.vec <- numeric(0)
linreg.pval.vec <- numeric(0)
for(i in 1:300){
print(i)
id <- rep(LETTERS[1:8], each=50)
id <- factor(id)
meanLength <- rep(rnorm(8, 0, sd=5), each=50)
sex <- factor(rep(rep(c("M", "F"), each=50), 4))
sexEffect <- ifelse(sex=="M", 0, 0)##NO SEX EFFECT
y <- 20+sexEffect+meanLength+rnorm(8*50, 0, 1)
dat <- data.frame(y,sex,id)
#plot(as.numeric(id), y, col=sex)
model1 <- lm(y~sex+id)
linreg.pval <- summary(model1)$coefficients[2,4]
linreg.pval.vec <- c(linreg.pval.vec, linreg.pval)
mixed.model <- lmer(y~sex+(1|id))
mixed.pval <- summary(mixed.model)$coefficients[2,5]
mixed.pval.vec <- c(mixed.pval.vec, mixed.pval)
}
par(mfrow=c(1,2))
hist(linreg.pval.vec)
hist(mixed.pval.vec)
summary(model1)
View(dat)
model1 <- lm(y~sex+id)
summary(model1)
summary(mixed.model)
plot(as.numeric(id), y, col=sex)
linreg.pval.vec
mixed.pval.vec
mixed.pval.vec < .05
mean(ifelse(mixed.pval.vec < .05, 1, 0))
mean(ifelse(linreg.pval.vec < .05, 1, 0))
mixed.pval.vec <- numeric(0)
linreg.pval.vec <- numeric(0)
for(i in 1:300){
print(i)
id <- rep(LETTERS[1:8], each=50)
id <- factor(id)
meanLength <- rep(rnorm(8, 0, sd=5), each=50)
sex <- factor(rep(rep(c("M", "F"), each=50), 4))
sexEffect <- ifelse(sex=="M", 0, 0)##NO SEX EFFECT
y <- 20+sexEffect+meanLength+rnorm(8*50, 0, 1)
dat <- data.frame(y,sex,id)
plot(as.numeric(id), y, col=sex)
model1 <- lm(y~sex+id)
linreg.pval <- summary(model1)$coefficients[2,4]
linreg.pval.vec <- c(linreg.pval.vec, linreg.pval)
mixed.model <- lmer(y~sex+(1|id))
mixed.pval <- summary(mixed.model)$coefficients[2,5]
mixed.pval.vec <- c(mixed.pval.vec, mixed.pval)
}
par(mfrow=c(1,2))
hist(linreg.pval.vec)
hist(mixed.pval.vec)
mean(linreg.pval.vec < .05)
mean(mixed.pval.vec < .05)
iris
head(iris)
plot(Petal.Length~Sepal.Length, data = iris)
plot(Petal.Length~Sepal.Length, data = iris, color = Species)
?par
plot(Petal.Length~Sepal.Length, data = iris, col = Species)
plot(Petal.Length~Sepal.Length, data = iris, col = transp(as.numeric(Species), .4))
model(Petal.Length~Sepal.Length*Species)
glm(Petal.Length~Sepal.Length*Species, data = iris)
m = glm(Petal.Length~Sepal.Length*Species, data = iris)
summary(m)
.1316+.6184
.8031-.1926
plot(Petal.Length~Sepal.Length, data = iris, col = Species)
points(x = iris$Sepal.Length, y = predict(m, type = "response"))
plot(Petal.Length~Sepal.Length, data = iris, col = Species)
par?
k
?points
lines(x = iris$Sepal.Length, y = predict(m, type = "response"))
plot(Petal.Length~Sepal.Length, data = iris, col = Species)
lines(x = iris$Sepal.Length, y = predict(m, type = "response"), col = iris$Species)
points(x = iris$Sepal.Length, y = predict(m, type = "response"), col = iris$Species)
plot(Petal.Length~Sepal.Length, data = iris, col = Species)
points(x = iris$Sepal.Length, y = predict(m, type = "response"), col = iris$Species)
points(x = iris$Sepal.Length, y = predict(m, type = "response"), col = iris$Species, type = "line")
m2 = glm(Petal.Length~Sepal.Length+Species, data = iris)
summary(m2)
plot(Petal.Length~Sepal.Length, data = iris, col = Species)
vec = runif(nrow(iris), 0, 1)
m3 = glm(Petal.Length~Sepal.Length*Species+vec, data = iris)
summary(m3)
AIC(m1)
AIC(m)
m3 = glm(Petal.Length~Sepal.Length*Species+vec, data = iris)
vec = runif(nrow(iris), 0, 1)
m3 = glm(Petal.Length~Sepal.Length*Species+vec, data = iris)
summary(m3)
plot(iris$Petal.Length~vec)
plot(iris$Petal.Length~vec, col = iris$Species)
vec = runif(nrow(iris), 0, 1)
plot(iris$Petal.Length~vec, col = iris$Species)
vec = runif(nrow(iris), 0, 1)
plot(iris$Petal.Length~vec, col = iris$Species)
m3 = glm(Petal.Length~Sepal.Length*Species+vec, data = iris)
summary(m3)
AIC(m)
age = runif(1000, 1, 20)
hw = log(age)+rnorm(1000,0,.3)
plot(hw~age)
plot(hw~age, las = 1)
plot(hw~age)
plot(hw~age, las = 1)
parasites = 15-10*log(age)+1.5*age+rnorm(1000,0,1)
plot(parasites~age)
m1 = glm(parasites~hw+age)
summary(m1)
plot(parasites~hw)
m2 = glm(parasites~hw+age+I(age^2))
summary(m2)
points(x = hw, y = predict(m1, type = "response"), col = 2)
plot(parasites~hw)
points(x = hw, y = predict(m1, type = "response"), col = age)
import(ggplot2)
package(ggplot2)
library(ggplot2)
ggplot(x = hw, y = predict(m1, type = "response"), color = age)
m3 = glm(parsites~log(age)+age+hw)
m3 = glm(parasites~log(age)+age+hw, data)
m3 = glm(parasites~log(age)+age+hw)
summary(m3)
?pairs
pairs(parasites, age, hw)
n <- 50
x <- y <- 1:n
model <- RMexp(scale=10) + RMnugget(var=1.2)
library(spatstat)
n <- 50
x <- y <- 1:n
model <- RMexp(scale=10) + RMnugget(var=1.2)
library(RandomFields)
n <- 50
x <- y <- 1:n
model <- RMexp(scale=10) + RMnugget(var=1.2)
simu <- RFsimulate(model, x, y)
xsamp <- sample(1:50,400, replace=T)
ysamp <- sample(1:50,400, replace=T)
xsamp2 <- xsamp[!duplicated(data.frame(xsamp, ysamp))]
ysamp2 <- ysamp[!duplicated(data.frame(xsamp, ysamp))]
dat <- c(as.matrix(simu)[cbind(xsamp2, ysamp2)])
dat2 <- data.frame(xsamp2, ysamp2, variable=dat)
library(spatstat)
library(RandomFields)
n <- 50
x <- y <- 1:n
model <- RMexp(scale=10) + RMnugget(var=1.2)
simu <- RFsimulate(model, x, y)
xsamp <- sample(1:50,400, replace=T)
ysamp <- sample(1:50,400, replace=T)
xsamp2 <- xsamp[!duplicated(data.frame(xsamp, ysamp))]
ysamp2 <- ysamp[!duplicated(data.frame(xsamp, ysamp))]
dat <- c(as.matrix(simu)[cbind(xsamp2, ysamp2)])
dat2 <- data.frame(xsamp2, ysamp2, variable=dat)
plot(im(as.matrix(simu), xrange=c(0,50), yrange=c(0,50)))
points(x = dat2$xsamp2, y = dat2$ysamp2)
install.packages("akima")
a = interp(xsamp2, ysamp2, dat2$variable)
?akima
??akima
install.packages("akima")
library(akima)
a = interp(xsamp2, ysamp2, dat2$variable)
View(a)
View(a)
plot(im(as.matrix(a)))
plot(im(as.matrix(a), xrange=c(0,50), yrange=c(0,50)))
plot(im(as.matrix(a$z), xrange=c(0,50), yrange=c(0,50)))
interb = interp(xsamp2, ysamp2, dat2$variable, extrap = T)
plot(im(as.matrix(intera$z), xrange=c(0,50), yrange=c(0,50)))
plot(im(as.matrix(interb$z), xrange=c(0,50), yrange=c(0,50)))
interb = interp(xsamp2, ysamp2, dat2$variable, extrap = T, linear = F)
plot(im(as.matrix(interb$z), xrange=c(0,50), yrange=c(0,50)))
library(spatstat)
library(RandomFields)
n <- 50
x <- y <- 1:n
model <- RMexp(scale=10) + RMnugget(var=1.2)
simu <- RFsimulate(model, x, y)
xsamp <- sample(1:50,400, replace=T)
ysamp <- sample(1:50,400, replace=T)
xsamp2 <- xsamp[!duplicated(data.frame(xsamp, ysamp))]
ysamp2 <- ysamp[!duplicated(data.frame(xsamp, ysamp))]
dat <- c(as.matrix(simu)[cbind(xsamp2, ysamp2)])
dat2 <- data.frame(xsamp2, ysamp2, variable=dat)
plot(im(as.matrix(simu), xrange=c(0,50), yrange=c(0,50)))
points(x = dat2$xsamp2, y = dat2$ysamp2)
library(akima)
intera = interp(xsamp2, ysamp2, dat2$variable)
plot(im(as.matrix(intera$z), xrange=c(0,50), yrange=c(0,50)))
interb = interp(xsamp2, ysamp2, dat2$variable, extrap = T, linear = F)
plot(im(as.matrix(interb$z), xrange=c(0,50), yrange=c(0,50)))
library(ggplot2)
library(tidyr)
library(dplyr)
library(gridExtra)
# generates line graphs or bar plots (as applicable) of the results provided based on:
# dtable - data frame of results, with columns for each parameter to split/graph by, and each category of results
# params - vector of column names to split/graph:
#   the lines/bars will be colored based on the last column listed
#   the x-axis will be based on the second to last column listed
#   the data will be split into graphs based on all the other columns (it will create one graph for each combination of values)
# fname - the beginning of the name of all the outputted files
#   it will add on all the names of the parameters split by and their values for each graph
# testvars - list of vectors of column names to plot together (y values) on the same graph
#   can be used to color the graph or for the x-axis if included in params as "category"
# testlabels - vector of labels for the y-axis of each graph, should be the same length as testvars
# catlabels - vector of labels for the colors of each graph, should be the same length as testvars
plotResults = function(dtable, params, fname, testvars, testlabels, catlabels, scatter = F,
linelabels = c(), shapelabels = c(), savelv = 2){
if(length(params) == savelv){
# loop through each set of measures to crete the corresponding plots
for(v in 1:length(testvars)) {
# format the data for ggplot
plotd = gather(dtable, category, measure, testvars[[v]])
# make sure nothing is infinite
is.na(plotd) = sapply(plotd, is.infinite)
# grab the x axis variable for convenience
plotd$x = plotd[, params[length(params)-1]]
# split the category to see if there are actually multiple
cats = strsplit(params[length(params)], " ")[[1]]
# the category can be split by color
plotd$c = ""
# by shape
plotd$s = ""
# and by linetype
plotd$l = ""
# I'm going to have an index here to increment
j = 1
# if the data is going to be split into shapes, use the first category for that
if(length(shapelabels) > 0){
plotd$s = factor(plotd[, cats[1]])
j = j+1
# also, if there's only one shape label given use that
if(length(shapelabels) == 1){
slab = shapelabels[1]
} else {
# otherwise, use the label corresponding to this test variable
slab = shapelabels[v]
}
} else {
slab = ""
}
# if there are more categories left and this is going to be split into linetypes, do so
if(length(cats) >= j & length(linelabels) > 0){
plotd$l = factor(plotd[, cats[j]])
j = j+1
# also set the line label
if(length(linelabels) == 1){
llab = linelabels[1]
} else {
llab = linelables[v]
}
} else {
llab = ""
}
# if there are more categories left, combine them for use as the color
if(length(cats) >= j) {
for(i in j:length(cats)){
plotd$c = paste(plotd$c, plotd[, cats[i]])
}
# also set the color label
if(length(catlabels) == 1){
clab = catlabels[1]
} else {
clab = catlables[v]
}
} else {
clab = ""
}
# turn the color into a factor
plotd$c = factor(plotd$c)
# if this isn't a scatter plot average the relevant measures so there aren't duplicates
if(!scatter){
plotd = summarize(group_by(group_by_at(plotd, params[1:(length(params)-2)]), x, c, s, l, add = T),
N = length(measure), mean = mean(measure, na.rm = T),
sd = sd(measure, na.rm = T), se = sd / sqrt(N))
plotd = as.data.frame(plotd)
}
# plot the results
# create a scatter plot if scatter is true
if(scatter){
plot = ggplot(plotd, aes(x = x, y = measure, colour = c)) + geom_point(aes(shape = s)) +
ylab(testlabels[v]) + xlab(params[length(params)-1]) + labs(colour = params[length(params)]) +
guides(colour=guide_legend(title=clab), shape=guide_legend(title=slab)) +
geom_smooth(method = 'lm', se = F)
} else if(is.numeric(plotd$x)){
# otherwise, if the x-axis is numeric, turn this into a linegraph
plot = ggplot(plotd, aes(x = x, y = mean, colour = c)) +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.1) + geom_line(aes(linetype = l)) +
geom_point(aes(shape = s, size = N/sum(N))) + ylab(testlabels[v]) + xlab(params[length(params)-1]) +
labs(colour = params[length(params)]) +
guides(colour=guide_legend(title=clab), shape=guide_legend(title=slab), linetype=guide_legend(title = llab))
} else {
# otherwise, turn it into a bargraph
plot = ggplot(plotd, aes(x = x, y = mean, fill = c)) +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.2, position=position_dodge(.9)) +
geom_bar(stat = "identity", position = "dodge") + ylab(testlabels[v]) + xlab(params[length(params)-1]) +
labs(fill = params[length(params)]) + guides(fill=guide_legend(title=clab))
}
# if the save level is higher than 2, make a grid of grids for all the remaining parameters
# if the save level is 3, just make a single row
if(savelv == 3){
plot = plot + facet_grid(cols = vars(plotd[, params[(length(params)-2)]]))
} else if (savelv > 3) {
# otherwise, make a grid from the last two parameters
plot = plot + facet_grid(rows = vars(plotd[, params[(length(params)-2)]]),
cols = vars(plotd[, params[(length(params)-3)]]))
}
ggsave(paste(fname, testlabels[v], ".png", sep = ""), plot = plot)
}
} else {
# otherwise, recurse on all values of this parameter
for(v in unique(dtable[, params[1]])){
# update the filename to pass it
f = paste(fname, params[1], v, sep = "")
# get the corresponding plot/grid of plots
plotResults(dtable[dtable[, params[1]] == v, ], params[-1], f, testvars, testlabels, catlabels,
scatter, linelabels = linelabels, shapelabels = shapelabels, savelv = savelv)
}
}
}
library(stringr)
combineFiles = function(fnames, paramIDs, endstrings, paramnames){
dtable = data.frame()
for(f in 1:length(fnames)){
if(substring(fnames[f], nchar(fnames[f])-3) == ".txt"){
d = read.table(fnames[f], header = TRUE, comment.char = "%", sep = "\t")
# find all the params and endstrings
splits = unlist(str_locate_all(fnames[f], c(paramIDs, endstrings)))
# store the starts and ends separately
starts = splits[c(T, F)]
ends = splits[c(F, T)]
# get the order of all the splits
splitorder = order(starts)
# loop through all the splits in order
for(s in 1:length(splitorder)){
# only use it if it's actually a parameter, not just an end string
if(splitorder[s] < length(paramnames)+1){
# grab the value between the end of this split and the beginning of the next
val = substr(fnames[f], ends[splitorder[s]]+1, starts[splitorder[s+1]]-1)
if(!is.na(as.numeric(val))) { val = as.numeric(val) }
# create a new column with the designated name and value
d[, paramnames[splitorder[s]]] = val
}
}
# now merge this dataframe with the previous
dtable = rbind(dtable, d)
}
}
# return the complete table
return(dtable)
}
setwd("Documents/Research/IMCapstone/ResultsCSVs/WithPredFlee/endresults")
d = combineFiles(list.files(), c("vig", "lb", "la"), c("Testendresults.txt"),
c("Vigilance","LocalBirth","LearnAlg"))
setwd("../../../RResults")
d4 = d[d$LearnAlg != 'b',]
d4$SocProp = d4$soccount/(d4$soccount + d4$vigcount + d4$indcount)
# log huntsteps will be more informative when it's used on the x-axis
d4$loghuntsteps = log(d4$huntsteps)
d4$VigProp = d4$vigcount/(d4$soccount + d4$vigcount + d4$indcount)
for(p1 in testparams){
for(p2 in testparams){
if(p1 != p2){
plotResults(d4, c(p1, p2), paste(p1, p2), list(c("VigProp")), c("Proportion of Vigilance Only"), catlabels = p2)
}
}
}
d5 = d2[d2$LearnAlg != 'b' & d2$Vigilance == "true",]
d5$VigProp = d5$vigcount/(d5$soccount + d5$vigcount + d5$indcount)
# I'm going to add log hunsteps, which will be more meaningful
d5$loghuntsteps = log(d5$huntsteps)
d4 = d[d$LearnAlg != 'b' & d$Vigilance == "true",]
d4$SocProp = d4$soccount/(d4$soccount + d4$vigcount + d4$indcount)
d4$VigProp = d4$vigcount/(d4$soccount + d4$vigcount + d4$indcount)
# log huntsteps will be more informative when it's used on the x-axis
d4$loghuntsteps = log(d4$huntsteps)
testparams = c("Vigilance", "LocalBirth", "loghuntsteps", "predflee", "stayforage", "foragediff", "predfreq", "LearnAlg")
for(p1 in testparams){
for(p2 in testparams){
if(p1 != p2){
plotResults(d4, c(p1, p2), paste(p1, p2), list(c("VigProp")), c("Proportion of Vigilance Only"), catlabels = p2)
}
}
}
testparams = c("LocalBirth", "loghuntsteps", "predflee", "stayforage", "foragediff", "predfreq", "LearnAlg")
for(p1 in testparams){
for(p2 in testparams){
if(p1 != p2){
plotResults(d4, c(p1, p2), paste(p1, p2), list(c("VigProp")), c("Proportion of Vigilance Only"), catlabels = p2)
}
}
}
